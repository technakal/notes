# Java Persistence API

- Java Persistence API (JPA) allows you to interact with a database in your Java code, without explicitly writing select/insert/update queries.
  - In a sense, it allows you to say, "I want to get this Java object from the database" or "I want to save this object to the database", and then it handles translating that to SQL.
  - It does this through Object Relational Mapping (ORM), which involves mapping Java objects to their corresponding relational tables (and vice versa).
- Spring also offers some shortcuts to integrating JPA, through the Spring Data library.

## Overview

- JPA is a Java package for accessing, persisting, and managing data between Java objects and a relational database.
- JPA allows for contract free objects, defined through annotations or XML.
- JPA was inspired by Hibernate, the pioneer in Java object persistence.

## Features of JPA

- Can perform Create, Read, Update and Delete, without using SQL.
- Can manage relationships between objects.
- Can write queries using a specialized JPA query language.

## Entities

- An object that is managed by JPA is called an Entity.
- JPA offers an interface `EntityManager` for working with Entities.
- An entity is a lightweight persistence domain object.
- Typically, an entity represents a table in a relational database, and each entity instance corresponds to a row in that table.
- Entities are typically represented in Java as entity classes, though they can be helper classes too.
- The persistent state of an entity is represented through either persistent fields or persistent properties.
  - These fields or properties use object/relational mapping annotations to map the entities and entity relationships to the relational data in the underlying data store.

### Entity Requirements

- For a class to be an entity class, it must meet the following requirements:
  - Use the `javax.persistence.Entity` annotation.
  - Must have a public or protected constructor that takes no arguments.
  - It must not be final or have any final methods or fields.
  - All fields must be private, protected, or package-private.

### Persistence Fields

- Anything not annotated `Transient` or marked transient by Java will be persisted to the database.
- Object/relational mapping annotations must be applied to instance variables.

### Primary Keys

- Each entity must have a primary key.
- The primary key allows the persistence API to identify a particular instance of an entity.
- Primary keys can be simple or composite.
  - A simple key is annotated with `javax.persistence.Id`.
- Primary keys can only be applied to a field that contains a Java primitive type or Java primitive wrapper:
  - java.lang.String
  - java.util.Date
  - java.sql.Date
  - java.math.BigDecimal
  - java.math.BigInteger
- Primary keys can be auto-generated via the `AutoGenerated` annotation.
  - There are four types of supported auto-generation:
    - AUTO (default)
      - For the default generation type, the persistence provider will determine values based on the type of the primary key attribute.
      - For numeric values, the generation is based on a sequence or table generator.
      - In this case, the primary key values will be unique at the database level.
    - IDENTITY
      - Expects the corresponding database column to be set to IDENTITY and AUTO_INCREMENT.
    - SEQUENCE
      - This generator uses sequences if supported by the database or switches to table generation if it doesnâ€™t.
      - To customize the sequence name, we can use the `@GenericGenerator` annotation with `SequenceStyleGenerator` strategy.
      - This one is quite a bit different from the options above. It requires a few more configurations, and doesn't use `@AutoGenerated`.
      - The generated values are unique per sequence.
      - If a sequence name is not specified, Hibernate will re-use the same hibernate_sequence for different types.
    - TABLE
      - The `TableGenerator` uses an underlying database table that holds segments of identifier generation values.

```java
// AUTO
@Entity
public class MyFirstEntity {

  @Id
  @AutoGenerated
  private Long id;

}

// IDENTITY
@Entity
public class MyFirstEntity {

  @Id
  @GeneratedValue(strategy = GenerationType.IDENTITY)
  private Long id;

}

// SEQUENCE
@Entity
public class MyFirstEntity {

  @Id
  @GeneratedValue(generator = "sequence-generator")
  @GenericGenerator(
    name: "sequence-generator",
    strategy = "org.hibernate.id.enhanced.SequenceStyleGenerator",
    parameters = {
      @Parameter(name = "sequence_name", value = "user_sequence"),
      @Parameter(name = "initial_value", value = "4"),
      @Parameter(name = "increment_size", value = "1")
    }
  )
  private Long id;

}

// TABLE
@Entity
public class MyFirstEntity {

  @Id
  @GeneratedValue(strategy = GenerationType.TABLE,
    generator = "table-generator")
  @TableGenerator(name = "table-generator",
    table = "dep_ids",
    pkColumnName = "seq_id",
    valueColumnName = "seq_value")
  private Long orderId;

}
```

### Specifying Table and Column Names

- There are also annotations for specifying the table and column names to which you want the Entity to match.
  - Obviously, it's the `@Table` and `@Column` annotations.

```java
@Entity
@Table(name = "my_table")
public class MyFirstEntity {

  @Id
  @GeneratedValue(strategy = GenerationType.IDENTITY)
  @Column(name = "order_id")
  private Long id;

}
```

### Entity Lifecycle

- When an entity is first created, it is transient.
  - The EntityManager is not aware of it, and if you don't do something to persist it, it gets garbase collected.
- Once it's persisted, using the EntityManager and persist method, it enters the persisted state.
  - In this state, the Entity has a linked to its cohort in the table, so any changes to the entity propogate to the entity.
- If an Entity should not be persisted, or some change to it shouldn't be, you can use the `detach()` method to detach it from the table.
- Removing an Entity from the database, using `remove()`, takes it out of the persistent state.
- The `find()` method retrieves an entity from the table, and that entity is immediately in the persisted state.

![Entity Lifecycle](./entity-lifecycle.png)

### General Process

- Create an `EntityManager` field.
- Open a connection with `begin()`.
- Do whatever you need to do.
  - Create an instance and persist it with `persist()`.
  - Load an existing Entity from the database via the `find()` method.
  - Delete one with `remove()`.
- Commit (persist) the changes with `commit()`.
- Close the transaction with `close()`.

- An example of creating an entity and persisting it.

```java
public class OrderTest {

  private static final String PERSISTENCE_UNIT_NAME = 'Order';

  private static EntityManagerFactory factory;

  public static void main(String[] args) {

    EntityManagerFactor factory = Persistence.createEntityManagerFactory(PERSISTENCE_UNIT_NAME);

    // create the entity manager
    EntityManager em = factory.createEntityManager();

    // open the transaction
    em.getTransaction().begin();

    // create the Entity instance
    Order order = new Order();
    order.setCustomerName("John Doe");
    order.setCustomerAddress("201 4th Street SW, West Bend, IA 50597");
    order.setCreatedTime(Timestamp.valueOf(LocalDateTime.now()));

    // persist the entity
    em.persist(order);
    em.getTransaction().commit();

    // close the connection
    em.close();
  }

}
```

- An example of retrieving an entity.

```java
private static void readOrder(Integer orderId, EntityManagerFactory factory) {

  EntityManager en = factory.createEntityManager();

  // retrieve the order by orderId (primary key) and create an entity for it.
  Order order = em.find(Order.class, orderId);

  System.err.println(order);

  em.close();

}
```

## Getting Started with JPA

- Create a `persistence.xml` file and add it to the classpath.
  - In the file, you'll define your connection variables and identify your entities.
  - Here's a [good resource](https://thoughts-on-java.org/jpa-persistence-xml/) on configuring the `persistence.xml`, with information on each element, and other configuration settings you can use.

```xml
<?xml version="1.0" encoding="UTF-8"?>
<persistence version="2.1"
    xmlns="http://xmlns.jcp.org/xml/ns/persistence" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/persistence http://xmlns.jcp.org/xml/ns/persistence/persistence_2_1.xsd">
  <persistence-unit name="TestPersistence" transaction-type="RESOURCE_LOCAL">
    <class><!-- Entity Manager Class Name, fully qualified --></class>
    <propert  ies>
      <property name="javax.persistence.jdbc.driver" value="Database Driver Name" />
      <property name="javax.persistence.jdbc.url" value="Database Url" />
      <property name="javax.persistence.jdbc.user" value="Database Username" />
      <property name="javax.persistence.jdbc.password" value="Database Password" />
    </properties>
  </persistence-unit>
</persistence>
```

- Build your entity class.
